
module Web.Hyperbole.Application where

-- import Control.Monad (forever, void)
-- import Data.ByteString.Lazy qualified as BL
-- import Data.String.Interpolate (i)
-- import Effectful
-- import Effectful.Concurrent.Async
-- import Effectful.Dispatch.Dynamic
-- import Effectful.Exception (SomeException, trySync)
-- import Network.Wai qualified as Wai
-- import Network.Wai.Handler.WebSockets (websocketsOr)
-- import Network.WebSockets (PendingConnection, defaultConnectionOptions)
-- import Network.WebSockets qualified as WS
-- import Web.Hyperbole.Effect.Hyperbole
-- import Web.Hyperbole.Effect.Request (reqPath)
-- import Web.Hyperbole.Effect.Server.Response
-- import Web.Hyperbole.Effect.Server.Socket (runServerSockets)
-- import Web.Hyperbole.Effect.Server.Socket qualified as Socket
-- import Web.Hyperbole.Effect.Server.Types
-- import Web.Hyperbole.Effect.Server.Wai (runServerWai)
-- import Web.Hyperbole.Route
-- import Web.Hyperbole.View.Embed (cssResetEmbed, scriptEmbed, scriptLiveReload)
--
--
-- waiApp :: (BL.ByteString -> BL.ByteString) -> Eff '[Hyperbole, Server, Concurrent, IOE] Response -> Wai.Application
-- waiApp toDoc actions req res = do
--   rr <- runEff $ runConcurrent $ runServerWai toDoc req res $ do
--     req' <- send LoadRequest
--     runHyperbole req' actions
--   case rr of
--     Nothing -> error "Missing required response in handler"
--     Just r -> pure r
--
--
-- -- TODO: implement sockets, for now it just logs messages
-- socketApp :: (IOE :> es, Concurrent :> es) => Eff (Hyperbole : Server : es) Response -> PendingConnection -> Eff es ()
-- socketApp actions pend = do
--   conn <- liftIO $ WS.acceptRequest pend
--   forever $ do
--     -- runServerSockets conn $ do
--     --   -- block loading the request
--     --   req <- send LoadRequest
--     --
--     --   -- run handler in the background = async
--     --   void $ async $ do
--     --     res <- trySync $ runHyperbole req actions
--     --     case res of
--     --       -- TODO: catch socket errors separately from SomeException?
--     --       Left (ex :: SomeException) -> do
--     --         -- It's not safe to send any exception over the wire
--     --         -- log it to the console and send the error to the client
--     --         liftIO $ print ex
--     --         res2 <- trySync $ Socket.sendError req.requestId conn (serverError "Internal Server Error")
--     --         case res2 of
--     --           Left e -> liftIO $ putStrLn $ "Socket Error while sending previous error to client: " <> show e
--     --           Right _ -> pure ()
--     --       Right _ -> pure ()
--     --
--     req <- receiveRequest conn
--     liftIO $ print req
--
-- {- | Route URL patterns to different pages
--
--
-- @
-- #EMBED Example/Docs/App.hs import Example.Docs.Page
--
-- #EMBED Example/Docs/App.hs type UserId
--
-- #EMBED Example/Docs/App.hs data AppRoute
--
-- #EMBED Example/Docs/App.hs instance Route
--
-- #EMBED Example/Docs/App.hs router
-- @
-- -}
-- routeRequest :: (Hyperbole :> es, Route route) => (route -> Eff es Response) -> Eff es Response
-- routeRequest actions = do
--   pth <- reqPath
--   case findRoute pth.segments of
--     Nothing -> send $ RespondNow NotFound
--     Just rt -> actions rt
